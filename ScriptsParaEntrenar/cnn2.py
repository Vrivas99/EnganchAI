# -*- coding: utf-8 -*-
"""Copy of Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17Ro5HS40_BRLLxNT2iY9PCuITUGc6-DW
"""

from google.colab import drive
#Cargar drive (ahi estan las imagenes)
drive.mount('/content/drive')

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.keras import layers, models

# Cargar los datos
def load_data(file_path):
    df = pd.read_csv(file_path)
    labels = df.iloc[:, 1:5].values  # Suponiendo que las primeras 4 columnas son las etiquetas
    embeddings = df.iloc[:, 5:].values  # Suponiendo que el resto son las embeddings
    return embeddings, labels

# Cargar los datos
train_embeddings, train_labels = load_data('/content/drive/MyDrive/DAISEE2/embedding_dataset/train_with_embeddings.csv')
val_embeddings, val_labels = load_data('/content/drive/MyDrive/DAISEE2/embedding_dataset/validation_with_embeddings.csv')

# Cambiar la forma de los embeddings para que sean 2D
# Suponiendo que 512 es el ancho y queremos hacer que sea 32x16 o algo similar
# Aquí simplemente redimensionamos a (N, 32, 16, 1) o (N, 16, 32, 1) según necesites
train_embeddings = train_embeddings.reshape(-1, 32, 16, 1)  # 32 x 16 = 512
val_embeddings = val_embeddings.reshape(-1, 32, 16, 1)  # 32 x 16 = 512

# Definir la arquitectura del modelo
def build_model():
    model = models.Sequential()
    model.add(layers.Input(shape=(32, 16, 1)))  # Cambiar a la forma 2D

    # Capa convolucional 1
    model.add(layers.Conv2D(filters=32, kernel_size=(5, 5), activation='relu', padding='same'))
    model.add(layers.MaxPooling2D(pool_size=(2, 2)))

    # Capa convolucional 2
    model.add(layers.Conv2D(filters=64, kernel_size=(5, 5), activation='relu', padding='same'))
    model.add(layers.MaxPooling2D(pool_size=(2, 2)))

    # Capa convolucional 3
    model.add(layers.Conv2D(filters=128, kernel_size=(5, 5), activation='relu', padding='same'))
    model.add(layers.MaxPooling2D(pool_size=(2, 2)))

    # Capa convolucional 4
    model.add(layers.Conv2D(filters=256, kernel_size=(5, 5), activation='relu', padding='same'))
    model.add(layers.MaxPooling2D(pool_size=(2, 2)))

    # Capa de Dropout
    model.add(layers.Dropout(0.25))

    # Aplanar la salida
    model.add(layers.Flatten())

    # Capa densa completamente conectada
    model.add(layers.Dense(128, activation='relu'))
    model.add(layers.Dropout(0.5))

    # Capa de salida con softmax
    model.add(layers.Dense(4, activation='sigmoid'))  # Para 4 clases

    return model

# Crear el modelo
model = build_model()

from tensorflow.keras import metrics
# Compilar el modelo
model.compile(optimizer='adam', loss='mean_squared_error', metrics=['accuracy',metrics.Precision(), metrics.Recall()])

# Entrenar el modelo
history = model.fit(train_embeddings, train_labels,
                    epochs=10,
                    batch_size=32,
                    validation_data=(val_embeddings, val_labels))

# Hacer predicciones
predictions = model.predict(val_embeddings)

# Redondear las predicciones para obtener las intensidades
predicted_classes = np.round(predictions)

# Mostrar algunas predicciones y valores verdaderos
for i in range(5):
    print(f"Predicted: {predicted_classes[i]}, True: {val_labels[i]}")